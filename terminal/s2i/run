#!/bin/bash

set -x

set -eo pipefail

# Add entry to /etc/passwd file.

STATUS=0 && whoami &> /dev/null || STATUS=$? && true

if [[ "$STATUS" != "0" ]]; then
    cat /etc/passwd | sed -e "s/^default:/builder:/" > /tmp/passwd
    echo "default:x:$(id -u):$(id -g):,,,:/opt/app-root/src:/bin/bash" >> /tmp/passwd
    cat /tmp/passwd > /etc/passwd
    rm /tmp/passwd
fi

# Setup 'oc' client configuration for the location of the OpenShift cluster.

CA_FILE="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"

if [ x"$KUBERNETES_PORT_443_TCP_ADDR" != x"" ]; then
    if [ -f $CA_FILE ]; then
        OC_CA_ARGS="--certificate-authority $CA_FILE"
    else
        OC_CA_ARGS="--insecure-skip-tls-verify"
    fi

    oc config set-cluster local $OC_CA_ARGS --server \
        "https://$KUBERNETES_PORT_443_TCP_ADDR:$KUBERNETES_PORT_443_TCP_PORT" 

    oc config set-context local --cluster local
    oc config use-context local
fi

# Try and work out the correct version of the command line tools to use
# if not explicitly defined by the template. This assumes you will be
# using the same cluster the deployment is to. We hope the above setup
# will work okay with the default 'oc' version if no version was defined
# and before we can work out the correct version to use.

if [ x"$KUBERNETES_PORT_443_TCP_ADDR" != x"" ]; then
    if [ -z "$KUBECTL_VERSION" ]; then
        KUBECTL_VERSION=`(/usr/local/bin/kubectl-1.11.0 version -o json | \
            python -c 'from __future__ import print_function; import sys, json; \
            info = json.loads(sys.stdin.read()).get("serverVersion"); \
            info and print("%s.%s" % (info["major"], info["minor"]))') || true`
    fi
fi

if [ -z "$OC_VERSION" ]; then
    case "$KUBECTL_VERSION" in
        1.10|1.10+)
            OC_VERSION=3.10
            ;;
        1.11|1.11+)
            OC_VERSION=3.11
            ;;
        1.12|1.12+)
            OC_VERSION=4.0
            ;;
    esac
fi

if [ -z "$ODO_VERSION" ]; then
    ODO_VERSION=0.0.19
fi

export OC_VERSION
export KUBECTL_VERSION
export ODO_VERSION

# Now attempt to login to the OpenShift cluster. First check whether we
# inherited a user access token mounted in through a configmap or from an
# emptydir volume initialised from an init container. If not, see if we
# have been passed in a username/password to use to login. Finally, see
# if service account token has been mounted into the container.

USER_TOKEN_FILE="/opt/app-root/user/token"
ACCT_TOKEN_FILE="/var/run/secrets/kubernetes.io/serviceaccount/token"

if [ x"$KUBERNETES_PORT_443_TCP_ADDR" != x"" ]; then
    if [ -f $USER_TOKEN_FILE ]; then
        oc login $OC_CA_ARGS --token `cat $USER_TOKEN_FILE` > /dev/null 2>&1
    else
        if [ x"$OPENSHIFT_USERNAME" != x"" -a x"$OPENSHIFT_PASSWORD" != x"" ]; then
            oc login $OC_CA_ARGS -u "$OPENSHIFT_USERNAME" -p "$OPENSHIFT_PASSWORD" > /dev/null 2>&1
            mkdir -p `dirname $USER_TOKEN_FILE`
            oc whoami --show-token > $USER_TOKEN_FILE
        else
            if [ -f $ACCT_TOKEN_FILE ]; then
                oc login $OC_CA_ARGS --token `cat $ACCT_TOKEN_FILE` > /dev/null 2>&1
            fi
        fi
    fi
fi

# If the host used in cluster subdomain for applications is not defined
# try and determine by querying the REST API. Ignore any errors.

if [ x"$CLUSTER_SUBDOMAIN" = x"" ]; then
    if [ x"$APPLICATION_NAME" = x"" ]; then
        APPLICATION_NAME=`echo $HOSTNAME | sed -e 's/-[0-9]*-[a-z0-9]*$//'`
    fi

    APPLICATION_HOST=`oc get route $APPLICATION_NAME -o template --template '{{.spec.host}}{{"\n"}}' 2>/dev/null || true`

    CLUSTER_SUBDOMAIN=`echo $APPLICATION_HOST | sed -e 's/[a-z0-9-]*\.//'`
    export CLUSTER_SUBDOMAIN
fi

# Run startup actions if supplied.

if [ -x /opt/app-root/etc/init.d/rc.local ]; then
    /opt/app-root/etc/init.d/rc.local
fi

# Run workshop specific initialisation.

if [ -x /opt/app-root/src/.workshop/setup ]; then
    /opt/app-root/src/.workshop/setup
fi

# Run supervisord.

exec supervisord --nodaemon \
    --configuration /opt/workshop/etc/supervisord.conf
